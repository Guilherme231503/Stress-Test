<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Canvas Bench Pro</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0a0a0a; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            color: #eee; 
            touch-action: none; 
        }
        canvas { 
            display: block; 
            margin: 0 auto; 
        }
        
        #ui-layer {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            pointer-events: none; 
            display: flex; 
            flex-direction: column; 
            padding: 15px; 
            box-sizing: border-box;
        }

        .panel {
            background: rgba(10, 10, 20, 0.9); 
            backdrop-filter: blur(12px);
            padding: 15px; 
            border-radius: 14px; 
            border: 1px solid rgba(0, 255, 204, 0.2);
            pointer-events: auto; 
            width: 100%; 
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .stats { 
            border-bottom: 1px solid rgba(0, 255, 204, 0.3); 
            margin-bottom: 15px; 
            padding-bottom: 10px; 
        }
        #fps { 
            font-size: 42px; 
            font-weight: 900; 
            color: #00ffcc; 
            display: block; 
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        
        .control-group { 
            margin-bottom: 15px; 
        }
        label { 
            display: block; 
            font-size: 11px; 
            text-transform: uppercase; 
            color: #aaa; 
            margin-bottom: 5px; 
            letter-spacing: 0.5px;
        }
        
        input[type=range] { 
            width: 100%; 
            accent-color: #00ffcc; 
            height: 10px; 
            background: #222; 
            border-radius: 5px;
        }
        
        .btn-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 10px; 
            pointer-events: auto; 
            margin-top: 15px;
        }
        button { 
            padding: 15px; 
            border-radius: 10px; 
            border: none; 
            background: linear-gradient(to bottom, #2a2a3a, #1a1a2a); 
            color: white; 
            font-weight: bold; 
            border: 1px solid rgba(0, 255, 204, 0.3);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }
        button:hover { 
            background: linear-gradient(to bottom, #3a3a4a, #2a2a3a);
            transform: translateY(-2px);
        }
        button:active { 
            transform: translateY(0);
            background: linear-gradient(to bottom, #1a1a2a, #0a0a1a);
        }
        
        #res-info {
            font-size: 12px;
            color: #888;
            display: block;
            margin-top: 5px;
        }
        
        #performance-info {
            font-size: 11px;
            color: #888;
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
        
        .danger {
            color: #ff5555 !important;
        }
    </style>
</head>
<body>

<canvas id="stage"></canvas>

<div id="ui-layer">
    <div class="panel">
        <div class="stats">
            <span id="fps">60 FPS</span>
            <small id="res-info">Resolução: 100% • Objetos: 0</small>
        </div>

        <div class="control-group">
            <label>Quantidade de Objetos: <span id="v-count">500</span></label>
            <input type="range" id="input-count" min="1" max="10000" value="500">
        </div>

        <div class="control-group">
            <label>Complexidade: <span id="v-teeth">8</span></label>
            <input type="range" id="input-teeth" min="3" max="100" value="8">
        </div>

        <div class="control-group">
            <label>Resolução: <span id="v-res">1.0</span>x</label>
            <input type="range" id="input-res" min="0.1" max="4.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Carga CPU (Primária): <span id="v-cpu">0</span></label>
            <input type="range" id="input-cpu" min="0" max="5000" value="0">
        </div>
        
        <div class="control-group">
            <label>Carga CPU (Secundária): <span id="v-cpu2">0</span></label>
            <input type="range" id="input-cpu2" min="0" max="10000" value="0">
        </div>
        
        <div class="control-group">
            <label>Sistema de Partículas: <span id="v-particles">0</span></label>
            <input type="range" id="input-particles" min="0" max="5000" value="0">
        </div>
        
        <div class="control-group">
            <label>Tipo de Forma: <span id="v-shape">Engrenagem</span></label>
            <select id="input-shape" style="width:100%; padding:8px; border-radius:6px; background:#222; color:#eee; border:1px solid #444;">
                <option value="gear">Engrenagem</option>
                <option value="star">Estrela Complexa</option>
                <option value="spiral">Espiral</option>
                <option value="polygon">Polígono Irregular</option>
                <option value="curve">Curva Bézier</option>
                <option value="mixed">Misto (Todos)</option>
            </select>
        </div>

        <div id="performance-info">
            <span id="draw-calls">Desenhos/quadro: 0</span><br>
            <span id="cpu-time">Tempo CPU: 0ms</span>
        </div>

        <div class="btn-grid">
            <button onclick="changeGears(-500)">-500 Objetos</button>
            <button onclick="changeGears(500)">+500 Objetos</button>
            <button onclick="toggleShadows()" id="shadow-btn">Sombra: ON</button>
            <button onclick="toggleBlur()" id="blur-btn">Blur: OFF</button>
            <button onclick="stressTest()" class="danger">STRESS TEST</button>
            <button onclick="resetTest()">RESETAR</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    
    let width, height;
    let gears = [];
    let particles = [];
    let settings = {
        count: 500,
        teeth: 8,
        res: 1.0,
        cpuLoad: 0,
        cpuLoad2: 0,
        particleCount: 0,
        shapeType: 'gear',
        shadows: true,
        blur: false,
        drawCalls: 0
    };

    // Performance tracking
    let lastTime = 0, frameCount = 0, fps = 0, lastFpsUpdate = 0;
    let lastCpuTime = 0, totalCpuTime = 0, cpuMeasurements = 0;

    // Complex mathematical functions for CPU stress
    function heavyMath1(iterations) {
        let result = 0;
        for(let i = 0; i < iterations; i++) {
            result += Math.sin(i) * Math.cos(i) * Math.tan(i % 180 * Math.PI / 180);
        }
        return result;
    }
    
    function heavyMath2(iterations) {
        let result = 0;
        for(let i = 0; i < iterations; i++) {
            // Complex fractal calculation simulation
            let x = 0, y = 0;
            for(let j = 0; j < 10; j++) {
                const xtemp = x * x - y * y + (i % 100) / 100;
                y = 2 * x * y + (j % 100) / 100;
                x = xtemp;
                result += Math.sqrt(x*x + y*y);
            }
        }
        return result;
    }
    
    function heavyMath3(iterations) {
        let result = 0;
        for(let i = 0; i < iterations; i++) {
            // Matrix multiplication simulation
            for(let j = 0; j < 5; j++) {
                for(let k = 0; k < 5; k++) {
                    result += Math.sin(i*j) * Math.cos(j*k) * Math.tan(k*i);
                }
            }
        }
        return result;
    }

    class Particle {
        constructor(x, y) {
            this.x = x || Math.random() * width;
            this.y = y || Math.random() * height;
            this.vx = (Math.random() - 0.5) * 4;
            this.vy = (Math.random() - 0.5) * 4;
            this.radius = Math.random() * 3 + 1;
            this.color = `hsla(${Math.random() * 360}, 100%, 70%, ${Math.random() * 0.5 + 0.2})`;
            this.life = Math.random() * 100 + 50;
            this.maxLife = this.life;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            
            if (this.x < 0 || this.x > width) this.vx *= -0.8;
            if (this.y < 0 || this.y > height) this.vy *= -0.8;
            
            // Add some randomness
            this.vx += (Math.random() - 0.5) * 0.1;
            this.vy += (Math.random() - 0.5) * 0.1;
            
            // Limit velocity
            const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (speed > 3) {
                this.vx = (this.vx / speed) * 3;
                this.vy = (this.vy / speed) * 3;
            }
            
            return this.life > 0;
        }
        
        draw() {
            ctx.save();
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            settings.drawCalls++;
        }
    }

    class ComplexShape {
        constructor() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.radius = 15 + Math.random() * 35;
            this.angle = Math.random() * Math.PI * 2;
            this.speed = (Math.random() - 0.5) * 0.05;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.02;
            this.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
            this.shapeType = settings.shapeType === 'mixed' ? 
                ['gear', 'star', 'spiral', 'polygon', 'curve'][Math.floor(Math.random() * 5)] : 
                settings.shapeType;
            this.innerRadius = this.radius * (0.3 + Math.random() * 0.3);
            this.spikes = Math.floor(3 + Math.random() * (settings.teeth - 3));
        }

        update() {
            const startTime = performance.now();
            
            this.angle += this.speed;
            this.x += this.vx; 
            this.y += this.vy;
            
            if (this.x < -this.radius || this.x > width + this.radius) this.vx *= -1;
            if (this.y < -this.radius || this.y > height + this.radius) this.vy *= -1;
            
            // Apply CPU stress tests
            if (settings.cpuLoad > 0) {
                heavyMath1(settings.cpuLoad);
            }
            
            if (settings.cpuLoad2 > 0) {
                heavyMath2(Math.floor(settings.cpuLoad2 / 100));
                heavyMath3(Math.floor(settings.cpuLoad2 / 200));
            }
            
            lastCpuTime += performance.now() - startTime;
            cpuMeasurements++;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            if (settings.shadows) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
            }
            
            ctx.fillStyle = this.color;
            ctx.beginPath();
            
            switch(this.shapeType) {
                case 'gear':
                    this.drawGear();
                    break;
                case 'star':
                    this.drawStar();
                    break;
                case 'spiral':
                    this.drawSpiral();
                    break;
                case 'polygon':
                    this.drawPolygon();
                    break;
                case 'curve':
                    this.drawCurve();
                    break;
            }
            
            ctx.closePath();
            ctx.fill();
            
            if (settings.shadows) {
                ctx.shadowColor = 'transparent';
            }
            
            // Inner detail
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(0, 0, this.innerRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            
            settings.drawCalls++;
            ctx.restore();
        }
        
        drawGear() {
            const segments = this.spikes * 2;
            for (let i = 0; i < segments; i++) {
                const r = (i % 2 === 0) ? this.radius : this.radius * 0.7;
                const theta = (Math.PI * 2 * i) / segments;
                if (i === 0) {
                    ctx.moveTo(r * Math.cos(theta), r * Math.sin(theta));
                } else {
                    ctx.lineTo(r * Math.cos(theta), r * Math.sin(theta));
                }
            }
        }
        
        drawStar() {
            const spikes = this.spikes * 2;
            for (let i = 0; i < spikes; i++) {
                const r = (i % 2 === 0) ? this.radius : this.radius * 0.5;
                const theta = (Math.PI * 2 * i) / spikes;
                if (i === 0) {
                    ctx.moveTo(r * Math.cos(theta), r * Math.sin(theta));
                } else {
                    ctx.lineTo(r * Math.cos(theta), r * Math.sin(theta));
                }
            }
        }
        
        drawSpiral() {
            const turns = 3;
            const points = 100;
            for (let i = 0; i <= points; i++) {
                const t = i / points;
                const angle = t * Math.PI * 2 * turns;
                const radius = this.radius * (1 - t * 0.7);
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
        }
        
        drawPolygon() {
            const sides = 3 + Math.floor(this.spikes / 2);
            const irregularity = 0.3;
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 * i) / sides;
                const radius = this.radius * (1 - irregularity + Math.random() * irregularity * 2);
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
        }
        
        drawCurve() {
            const cp = [];
            for (let i = 0; i < 4; i++) {
                cp.push({
                    x: (Math.random() - 0.5) * this.radius * 2,
                    y: (Math.random() - 0.5) * this.radius * 2
                });
            }
            
            ctx.moveTo(cp[0].x, cp[0].y);
            for (let i = 1; i < cp.length; i += 3) {
                ctx.bezierCurveTo(
                    cp[i].x, cp[i].y,
                    cp[i+1]?.x || cp[0].x, cp[i+1]?.y || cp[0].y,
                    cp[i+2]?.x || cp[0].x, cp[i+2]?.y || cp[0].y
                );
            }
        }
    }

    function initShapes() {
        gears = [];
        for(let i = 0; i < settings.count; i++) {
            gears.push(new ComplexShape());
        }
    }

    function updateParticles() {
        // Add new particles if needed
        while (particles.length < settings.particleCount && particles.length < 10000) {
            particles.push(new Particle());
        }
        
        // Remove excess particles
        while (particles.length > settings.particleCount) {
            particles.pop();
        }
        
        // Update existing particles
        for (let i = particles.length - 1; i >= 0; i--) {
            if (!particles[i].update()) {
                particles.splice(i, 1);
            }
        }
    }

    function syncCanvas() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * settings.res;
        canvas.height = height * settings.res;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        
        // Reset transform and set new scale
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(settings.res, settings.res);
    }

    // Event listeners for controls
    document.getElementById('input-count').oninput = function() {
        settings.count = parseInt(this.value);
        document.getElementById('v-count').innerText = settings.count;
        initShapes();
    };
    
    document.getElementById('input-teeth').oninput = function() {
        settings.teeth = parseInt(this.value);
        document.getElementById('v-teeth').innerText = this.value;
    };
    
    document.getElementById('input-res').oninput = function() {
        settings.res = parseFloat(this.value);
        document.getElementById('v-res').innerText = settings.res.toFixed(1);
        syncCanvas();
    };
    
    document.getElementById('input-cpu').oninput = function() {
        settings.cpuLoad = parseInt(this.value);
        document.getElementById('v-cpu').innerText = this.value;
    };
    
    document.getElementById('input-cpu2').oninput = function() {
        settings.cpuLoad2 = parseInt(this.value);
        document.getElementById('v-cpu2').innerText = this.value;
    };
    
    document.getElementById('input-particles').oninput = function() {
        settings.particleCount = parseInt(this.value);
        document.getElementById('v-particles').innerText = this.value;
    };
    
    document.getElementById('input-shape').onchange = function() {
        settings.shapeType = this.value;
        document.getElementById('v-shape').innerText = this.options[this.selectedIndex].text;
        initShapes();
    };

    function changeGears(amt) {
        let val = parseInt(document.getElementById('input-count').value) + amt;
        if (val < 1) val = 1;
        if (val > 10000) val = 10000;
        document.getElementById('input-count').value = val;
        document.getElementById('input-count').oninput();
    }
    
    function toggleShadows() {
        settings.shadows = !settings.shadows;
        document.getElementById('shadow-btn').innerText = 'Sombra: ' + (settings.shadows ? 'ON' : 'OFF');
    }
    
    function toggleBlur() {
        settings.blur = !settings.blur;
        document.getElementById('blur-btn').innerText = 'Blur: ' + (settings.blur ? 'ON' : 'OFF');
    }
    
    function stressTest() {
        document.getElementById('input-count').value = 10000;
        document.getElementById('input-count').oninput();
        
        document.getElementById('input-teeth').value = 100;
        document.getElementById('input-teeth').oninput();
        
        document.getElementById('input-cpu').value = 5000;
        document.getElementById('input-cpu').oninput();
        
        document.getElementById('input-cpu2').value = 10000;
        document.getElementById('input-cpu2').oninput();
        
        document.getElementById('input-particles').value = 5000;
        document.getElementById('input-particles').oninput();
    }
    
    function resetTest() {
        document.getElementById('input-count').value = 500;
        document.getElementById('input-count').oninput();
        
        document.getElementById('input-teeth').value = 8;
        document.getElementById('input-teeth').oninput();
        
        document.getElementById('input-cpu').value = 0;
        document.getElementById('input-cpu').oninput();
        
        document.getElementById('input-cpu2').value = 0;
        document.getElementById('input-cpu2').oninput();
        
        document.getElementById('input-particles').value = 0;
        document.getElementById('input-particles').oninput();
        
        document.getElementById('input-res').value = 1.0;
        document.getElementById('input-res').oninput();
        
        document.getElementById('input-shape').value = 'gear';
        document.getElementById('input-shape').onchange();
        
        settings.shadows = true;
        settings.blur = false;
        document.getElementById('shadow-btn').innerText = 'Sombra: ON';
        document.getElementById('blur-btn').innerText = 'Blur: OFF';
    }

    function render(time) {
        frameCount++;
        if (time - lastFpsUpdate > 1000) {
            fps = Math.round(frameCount * 1000 / (time - lastFpsUpdate));
            frameCount = 0;
            lastFpsUpdate = time;
            
            document.getElementById('fps').innerText = fps + " FPS";
            document.getElementById('fps').style.color = fps < 15 ? '#ff4444' : 
                (fps < 30 ? '#ffaa00' : (fps < 45 ? '#ffff00' : '#00ffcc'));
            
            // Update performance info
            document.getElementById('res-info').innerText = 
                `Resolução: ${Math.round(settings.res * 100)}% • Objetos: ${settings.count} • Partículas: ${particles.length}`;
                
            const avgCpuTime = cpuMeasurements > 0 ? totalCpuTime / cpuMeasurements : 0;
            document.getElementById('cpu-time').innerText = `Tempo CPU/quadro: ${avgCpuTime.toFixed(2)}ms`;
            document.getElementById('draw-calls').innerText = `Desenhos/quadro: ${settings.drawCalls}`;
            
            // Reset measurements
            totalCpuTime = 0;
            cpuMeasurements = 0;
            settings.drawCalls = 0;
        }

        // Clear canvas with optional blur effect
        if (settings.blur) {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, width, height);
        } else {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
        }
        
        // Reset CPU time measurement for this frame
        lastCpuTime = 0;
        
        // Update and draw shapes
        for(let i = 0; i < gears.length; i++) {
            gears[i].update();
            gears[i].draw();
        }
        
        // Update and draw particles
        updateParticles();
        for(let i = 0; i < particles.length; i++) {
            particles[i].draw();
        }
        
        // Accumulate CPU time
        totalCpuTime += lastCpuTime;

        requestAnimationFrame(render);
    }

    window.onresize = syncCanvas;
    syncCanvas();
    initShapes();
    requestAnimationFrame(render);

</script>
</body>
</html>